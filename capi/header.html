

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Public Header &mdash; liblightnvm 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="liblightnvm 0.0.1 documentation" href="../index.html"/>
        <link rel="up" title="C API" href="index.html"/>
        <link rel="next" title="Command-Line Interface" href="../cli/index.html"/>
        <link rel="prev" title="nvm_bounds" href="nvm_bounds.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> liblightnvm
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prereqs/index.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nvm_dev.html">nvm_dev - Device Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_geo.html">nvm_geo - Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_buf.html">nvm_buf - Buffer Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_addr.html">nvm_addr - Addressing</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_bbt.html">nvm_bbt - Bad-Block-Table</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_vblk.html">nvm_vblk - Virtual Block</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_cmd.html">nvm_cmd - Raw Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvm_lba.html">nvm_lba - LBA Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Public Header</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cli/index.html">Command-Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../refs/index.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">liblightnvm</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">C API</a> &raquo;</li>
        
      <li>Public Header</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/capi/header.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="public-header">
<span id="sec-capi-header"></span><h1>Public Header<a class="headerlink" href="#public-header" title="Permalink to this headline">¶</a></h1>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * User space I/O library for Open-Channel SSDs</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2015-2017 Javier Gonzáles &lt;javier@cnexlabs.com&gt;</span>
<span class="cm"> * Copyright (C) 2015-2017 Matias Bjørling &lt;matias@cnexlabs.com&gt;</span>
<span class="cm"> * Copyright (C) 2015-2017 Simon A. F. Lund &lt;slund@cnexlabs.com&gt;</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  - Redistributions of source code must retain the above copyright notice,</span>
<span class="cm"> *  this list of conditions and the following disclaimer.</span>
<span class="cm"> *  - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm"> *  this list of conditions and the following disclaimer in the documentation</span>
<span class="cm"> *  and/or other materials provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&#39;&#39; AND ANY</span>
<span class="cm"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * @file liblightnvm.h</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LIBLIGHTNVM_H</span>
<span class="cp">#define __LIBLIGHTNVM_H</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;liblightnvm_spec.h&gt;</span><span class="cp"></span>

<span class="cp">#define NVM_NADDR_MAX 64</span>

<span class="cp">#define NVM_DEV_NAME_LEN 32</span>
<span class="cp">#define NVM_DEV_PATH_LEN (NVM_DEV_NAME_LEN + 5)</span>

<span class="cp">#define NVM_FLAG_SCRBL 0x200	</span><span class="c1">///&lt; Scrambler ON/OFF: Context sensitive</span>

<span class="cm">/**</span>
<span class="cm"> * Enumeration of cmd back-ends used by liblightnvm</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nvm_be_id</span> <span class="p">{</span>
	<span class="n">NVM_BE_ANY</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; Flag for ANY backend</span>
	<span class="n">NVM_BE_IOCTL</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; Flag for the IOCTL backend</span>
	<span class="n">NVM_BE_SYSFS</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; Flag for the IOCTL + sysfs backend</span>
	<span class="n">NVM_BE_LBA</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	<span class="c1">///&lt; Flag for the IOCTL + sysfs + LBA backend</span>
<span class="p">};</span>
<span class="cp">#define NVM_BE_ALL (NVM_BE_IOCTL | NVM_BE_SYSFS | NVM_BE_LBA)	</span><span class="c1">///&lt; All be identifiers</span>

<span class="cm">/**</span>
<span class="cm"> * Plane-mode access for IO</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nvm_pmode</span> <span class="p">{</span>
	<span class="n">NVM_FLAG_PMODE_SNGL</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; Single-plane</span>
	<span class="n">NVM_FLAG_PMODE_DUAL</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; Dual-plane (NVM_IO_DUAL_ACCESS)</span>
	<span class="n">NVM_FLAG_PMODE_QUAD</span> <span class="o">=</span> <span class="mh">0x2</span>	<span class="c1">///&lt; Quad-plane (NVM_IO_QUAD_ACCESS)</span>
<span class="p">};</span>
<span class="cp">#define NVM_FLAG_DEFAULT (NVM_FLAG_PMODE_SNGL | NVM_FLAG_SCRBL);</span>

<span class="cm">/**</span>
<span class="cm"> * Opaque handle for NVM devices</span>
<span class="cm"> *</span>
<span class="cm"> * @struct nvm_dev</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Virtual block abstraction</span>
<span class="cm"> *</span>
<span class="cm"> * Facilitates a libc-like read/write and a system-like `pread`/`pwrite`</span>
<span class="cm"> * interface to perform I/O on a virtual block spanning multiple blocks of</span>
<span class="cm"> * physical NVM.</span>
<span class="cm"> *</span>
<span class="cm"> * Consult the `nvm_vblk_alloc`, `nvm_vblk_alloc_line` for the different spans</span>
<span class="cm"> *</span>
<span class="cm"> * @see nvm_vblk_alloc</span>
<span class="cm"> * @see nvm_vblk_alloc_line</span>
<span class="cm"> *</span>
<span class="cm"> * @struct nvm_vblk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_vblk</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Enumeration of pseudo meta mode</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nvm_meta_mode</span> <span class="p">{</span>
	<span class="n">NVM_META_MODE_NONE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">NVM_META_MODE_ALPHA</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">NVM_META_MODE_CONST</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Enumeration of device bounds</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nvm_bounds</span> <span class="p">{</span>
	<span class="n">NVM_BOUNDS_CHANNEL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">NVM_BOUNDS_LUN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">NVM_BOUNDS_PLANE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">NVM_BOUNDS_BLOCK</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">NVM_BOUNDS_PAGE</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">NVM_BOUNDS_SECTOR</span> <span class="o">=</span> <span class="mi">32</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation and representation of lower-level error conditions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_ret</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">status</span><span class="p">;</span>	<span class="c1">///&lt; NVMe command status / completion bits</span>
	<span class="kt">uint32_t</span> <span class="n">result</span><span class="p">;</span>	<span class="c1">///&lt; NVMe command error codes</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @struct nvm_cmd_vuser</span>
<span class="cm"> * @struct nvm_cmd_vadmin</span>
<span class="cm"> * @struct nvm_cmd_user</span>
<span class="cm"> * @struct nvm_cmd_admin</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation of lowest-level user and admin commands</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="n">opcode</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">control</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">nppas</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">rsvd</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">metadata</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">ppa_list</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">metadata_len</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">data_len</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">status</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">result</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">rsvd3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">vuser</span><span class="p">;</span>	<span class="c1">///&lt; Common fields for vector user commands</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="n">opcode</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw2</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw3</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">metadata</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">metadata_len</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">data_len</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">ppa_list</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">nppas</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">control</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw13</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw14</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw15</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">status</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">result</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">timeout_ms</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">vadmin</span><span class="p">;</span>	<span class="c1">///&lt; Common fields for vector admin commands</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="n">opcode</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">rsvd1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw2</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw3</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">metadata</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">metadata_len</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">data_len</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw10</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw11</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw12</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw13</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw14</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">cdw15</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">timeout_ms</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">result</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">admin</span><span class="p">;</span>	<span class="c1">///&lt; Common fields for admin commands</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="n">opcode</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">control</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">nblocks</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">rsvd</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">metadata</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">dsmgmt</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">reftag</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">apptag</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="n">appmask</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">user</span><span class="p">;</span>		<span class="c1">///&lt; Common fields for user commands</span>

		<span class="kt">uint32_t</span> <span class="n">cdw</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>	<span class="c1">///&lt; Command as array of dwords</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Obtain string representation of the given plane-mode</span>
<span class="cm"> *</span>
<span class="cm"> * @param pmode The plane-mode to obtain string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, string representation of the given plane-mode. On error,</span>
<span class="cm"> * &quot;UNKN&quot;.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nvm_pmode_str</span><span class="p">(</span><span class="kt">int</span> <span class="n">pmode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Execute an user command on the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param cmd The command to execute</span>
<span class="cm"> * @param ret Pointer to struct to fill with lower-level result-codes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_cmd_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Execute an admin command on the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param cmd The command to execute</span>
<span class="cm"> * @param ret Pointer to struct to fill with lower-level result-codes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_cmd_admin</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Execute a vector user command on the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param cmd The command to execute</span>
<span class="cm"> * @param ret Pointer to struct to fill with lower-level result-codes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_cmd_vuser</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Execute a vector admin command on the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param cmd The command to execute</span>
<span class="cm"> * @param ret Pointer to struct to fill with lower-level result-codes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_cmd_vadmin</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a text-representation of the given command</span>
<span class="cm"> *</span>
<span class="cm"> * @param cmd The command to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_cmd_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a textual presentation of the vuser par of the given command</span>
<span class="cm"> *</span>
<span class="cm"> * @param cmd The command to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_cmd_vuser_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation of generic physical nvm addressing</span>
<span class="cm"> *</span>
<span class="cm"> * Although the user need not worry about device specific address formats the</span>
<span class="cm"> * user has to know and respect addressing within device specific geometric</span>
<span class="cm"> * boundaries.</span>
<span class="cm"> *</span>
<span class="cm"> * For that purpose one can use the `struct nvm_geo` of an `struct nvm_dev` to</span>
<span class="cm"> * obtain device specific geometries.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/**</span>
<span class="cm">		 * Address packing and geometric accessors</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="nl">blk</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Block address</span>
			<span class="kt">uint64_t</span> <span class="nl">pg</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Page address</span>
			<span class="kt">uint64_t</span> <span class="nl">sec</span>	<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Sector address</span>
			<span class="kt">uint64_t</span> <span class="nl">pl</span>	<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Plane address</span>
			<span class="kt">uint64_t</span> <span class="nl">lun</span>	<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; LUN address</span>
			<span class="kt">uint64_t</span> <span class="nl">ch</span>	<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>	<span class="c1">///&lt; Channel address</span>
			<span class="kt">uint64_t</span> <span class="nl">rsvd</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Reserved</span>
		<span class="p">}</span> <span class="n">g</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="nl">line</span>		<span class="p">:</span> <span class="mi">63</span><span class="p">;</span>	<span class="c1">///&lt; Address line</span>
			<span class="kt">uint64_t</span> <span class="nl">is_cached</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Cache hint?</span>
		<span class="p">}</span> <span class="n">c</span><span class="p">;</span>

		<span class="kt">uint64_t</span> <span class="n">ppa</span><span class="p">;</span>				<span class="c1">///&lt; Address as ppa</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of device and virtual block geometry</span>
<span class="cm"> *</span>
<span class="cm"> * @see nvm_dev_get_geo, nvm_vblk_get_geo</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_geo</span> <span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">nchannels</span><span class="p">;</span>	<span class="c1">///&lt; Number of channels on device</span>
	<span class="kt">size_t</span> <span class="n">nluns</span><span class="p">;</span>		<span class="c1">///&lt; Number of LUNs per channel</span>
	<span class="kt">size_t</span> <span class="n">nplanes</span><span class="p">;</span>		<span class="c1">///&lt; Number of planes per LUN</span>
	<span class="kt">size_t</span> <span class="n">nblocks</span><span class="p">;</span>		<span class="c1">///&lt; Number of blocks per plane</span>
	<span class="kt">size_t</span> <span class="n">npages</span><span class="p">;</span>		<span class="c1">///&lt; Number of pages per block</span>
	<span class="kt">size_t</span> <span class="n">nsectors</span><span class="p">;</span>	<span class="c1">///&lt; Number of sectors per page</span>

	<span class="kt">size_t</span> <span class="n">page_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Number of bytes per page</span>
	<span class="kt">size_t</span> <span class="n">sector_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Number of bytes per sector</span>
	<span class="kt">size_t</span> <span class="n">meta_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Number of bytes for out-of-bound / metadata</span>

	<span class="kt">size_t</span> <span class="n">tbytes</span><span class="p">;</span>		<span class="c1">///&lt; Total number of bytes in geometry</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of valid values of bad-block-table states</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">nvm_bbt_state</span> <span class="p">{</span>
	<span class="n">NVM_BBT_FREE</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; Block is free AKA good</span>
	<span class="n">NVM_BBT_BAD</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; Block is bad</span>
	<span class="n">NVM_BBT_GBAD</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; Block has grown bad</span>
	<span class="n">NVM_BBT_DMRK</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	<span class="c1">///&lt; Block has been marked by device side</span>
	<span class="n">NVM_BBT_HMRK</span> <span class="o">=</span> <span class="mh">0x8</span>	<span class="c1">///&lt; Block has been marked by host side</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of bad-block-table</span>
<span class="cm"> *</span>
<span class="cm"> * The bad-block-table describes block-state of a given LUN</span>
<span class="cm"> *</span>
<span class="cm"> * @see nvm_bbt_get, nvm_bbt_set, nvm_bbt_mark, nvm_bbt_free, and nvm_bbt_pr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>	<span class="c1">///&lt; Device on which the bbt resides</span>
	<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">;</span>	<span class="c1">///&lt; Address of the LUN described by the bbt</span>
	<span class="kt">uint64_t</span> <span class="n">nblks</span><span class="p">;</span>		<span class="c1">///&lt; Total # of blocks in lun</span>
	<span class="kt">uint32_t</span> <span class="n">nbad</span><span class="p">;</span>		<span class="c1">///&lt; # of manufacturer marked bad blocks</span>
	<span class="kt">uint32_t</span> <span class="n">ngbad</span><span class="p">;</span>		<span class="c1">///&lt; # of grown bad blocks</span>
	<span class="kt">uint32_t</span> <span class="n">ndmrk</span><span class="p">;</span>		<span class="c1">///&lt; # of device reserved/marked blocks</span>
	<span class="kt">uint32_t</span> <span class="n">nhmrk</span><span class="p">;</span>		<span class="c1">///&lt; # of of host reserved/marked blocks</span>
	<span class="kt">uint8_t</span> <span class="n">blks</span><span class="p">[];</span>		<span class="c1">///&lt; Array of block status for each block in LUN</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @returns the &quot;major&quot; version of the library</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_ver_major</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @returns the &quot;minor&quot; version of the library</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_ver_minor</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @returns the &quot;patch&quot; version of the library</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_ver_patch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints version information about the library</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_ver_pr</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable description of given boundary mask</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_bounds_pr</span><span class="p">(</span><span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read up to `count` bytes from the given `device` starting at the given</span>
<span class="cm"> * `offset` into the given buffer starting at `buf`.</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * This is equivalent to `pread`/`pwrite` except it takes the opaque `struct</span>
<span class="cm"> * nvm_dev *` instead of a file descriptor</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_lba_pread</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		      <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write up to `count` bytes from the buffer starting at `buf` to the given</span>
<span class="cm"> * device `dev` at given `offset`.</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * This is equivalent to `pread`/`pwrite` except it takes the opaque `struct</span>
<span class="cm"> * nvm_dev *` instead of a file descriptor</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_lba_pwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		       <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation the given `struct nvm_ret`</span>
<span class="cm"> *</span>
<span class="cm"> * @param ret Pointer to the `struct nvm_ret` to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_ret_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieves a bad block table from device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr Address of the LUN to retrieve bad-block-table for</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result</span>
<span class="cm"> * @returns On success, a pointer to the bad-block-table is returned. On error,</span>
<span class="cm"> * NULL is returned, `errno` set to indicate the error and ret filled with</span>
<span class="cm"> * lower-level result codes</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="nf">nvm_bbt_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Updates the bad-block-table on given device using the provided bbt</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param bbt The bbt to write to device</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_bbt_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="n">bbt</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Mark addresses good, bad, or host-bad.</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * The addresses given to this function are interpreted as block addresses, in</span>
<span class="cm"> * contrast to `nvm_addr_write`, and `nvm_addr_read` which interpret addresses</span>
<span class="cm"> * and sector addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * @see `enum nvm_bbt_state`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addrs Array of memory address</span>
<span class="cm"> * @param naddrs Length of memory address array</span>
<span class="cm"> * @param flags 0x0 = GOOD, 0x1 = BAD, 0x2 = GROWN_BAD, as well as access mode</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result.</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_bbt_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addrs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">,</span>
		 <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Persist the bad-block-table at `addr` on device and deallocate managed memory</span>
<span class="cm"> * for the given bad-block-table describing the LUN at `addr`.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr Address of the LUN to flush bad-block-table for</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_bbt_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Persist all bad-block-tables associated with the given `dev`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned, `errno` set to</span>
<span class="cm"> * indicate the error and ret filled with lower-level result codes</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_bbt_flush_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a copy of the given bad-block-table</span>
<span class="cm"> *</span>
<span class="cm"> * @param bbt Pointer to the bad-block-table to copy</span>
<span class="cm"> * @returns On success, a pointer to a write-able copy of the given bbt is</span>
<span class="cm"> * returned. On error, NULL is returned and errno set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="nf">nvm_bbt_alloc_cp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="n">bbt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroys a given bad-block-table</span>
<span class="cm"> *</span>
<span class="cm"> * @param bbt The bad-block-table to destroy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_bbt_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="n">bbt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation of the given bad-block-table</span>
<span class="cm"> *</span>
<span class="cm"> * @param bbt The bad-block-table to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_bbt_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_bbt</span> <span class="o">*</span><span class="n">bbt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation of the given bad-block-table state</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_bbt_state_pr</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints human readable representation of the given geometry</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_geo_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Creates a handle to given device path</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev_path Path of the device to open e.g. &quot;/dev/nvme0n1&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * @returns A handle to the device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="nf">nvm_dev_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Creates a handle to given device path</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev_path Path of the device to open e.g. &quot;/dev/nvme0n1&quot;</span>
<span class="cm"> * @param flags Flags for opening device in different modes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns A handle to the device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="nf">nvm_dev_openf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroys device-handle</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints misc. device attribute associated with the given handle</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_dev_attr_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints all information about the device associated with the given handle</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_dev_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the file-descriptor associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, file descriptor is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_fd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the name associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, string is returned. On error, NULL is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nvm_dev_get_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the path associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, string is returned. On error, NULL is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">nvm_dev_get_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVME namespace identifier of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, NVME namespace identifier is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_nsid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the verid of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, verid is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_verid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the media-controller capabilities mask of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, capabilities mask is returned</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span> <span class="nf">nvm_dev_get_mccap</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the default plane_mode of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, pmode flag is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_pmode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the default plane-mode for the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param pmode Default plane-mode</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_pmode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the ppa-format of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, ppa-format is returned</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_spec_ppaf_nand</span> <span class="o">*</span><span class="nf">nvm_dev_get_ppaf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the ppa-format mask of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, ppa-format mask is returned</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_spec_ppaf_nand_mask</span> <span class="o">*</span><span class="nf">nvm_dev_get_ppaf_mask</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the &#39;meta-mode&#39; of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @return On success, meta-mode is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_meta_mode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the default &#39;meta-mode&#39; of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @returns On success, 0 is returned. On error, -1 is returned and errno set to</span>
<span class="cm"> * indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_meta_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">meta_mode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the maximum number of addresses to use when sending erases to device.</span>
<span class="cm"> * That is, when invoking nvm_addr_erase.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_erase_naddrs_max</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns whether caching is enabled for bad-block-tables on the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * 0 = cache disabled</span>
<span class="cm"> * 1 = cache enabled</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_bbts_cached</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the backend identifier associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_be_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the maximum number of addresses to use for reads, that is, when invoking</span>
<span class="cm"> * nvm_addr_read</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_read_naddrs_max</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the maximum number of addresses to use for writes, that is, when invoking</span>
<span class="cm"> * nvm_addr_write</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_get_write_naddrs_max</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the maximum number of addresses to use for erases, that is, when invoking</span>
<span class="cm"> * nvm_addr_erase</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param naddrs The maximum</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_erase_naddrs_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Sets whether retrieval and changes to bad-block-tables should be cached.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param bbts_cached 1 = cache enabled, 0 = cache disabled</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_bbts_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bbts_cached</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the maximum number of addresses to use for erases, that is, when invoking</span>
<span class="cm"> * nvm_addr_erase.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param naddrs The maximum</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_read_naddrs_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Set the maximum number of addresses to use for erases, that is, when invoking</span>
<span class="cm"> * nvm_addr_erase.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param naddrs The maximum</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_dev_set_write_naddrs_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the geometry of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * See struct nvm_geo for the specifics of the returned geometry</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> *</span>
<span class="cm"> * @returns The geometry (struct nvm_geo) of given device handle</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_geo</span> <span class="o">*</span><span class="nf">nvm_dev_get_geo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a buffer aligned to match the given geometry</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * nbytes must be greater than zero and a multiple of minimal granularity</span>
<span class="cm"> *</span>
<span class="cm"> * @param geo The geometry to get alignment information from</span>
<span class="cm"> * @param nbytes The size of the allocated buffer in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * @returns A pointer to the allocated memory. On error: NULL is returned and</span>
<span class="cm"> * `errno` set appropriatly</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">nvm_buf_alloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Fills `buf` with chars A-Z</span>
<span class="cm"> *</span>
<span class="cm"> * @param buf Pointer to the buffer to fill</span>
<span class="cm"> * @param nbytes Amount of bytes to fill in buf</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_buf_fill</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints `buf` to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param buf Pointer to the buffer to print</span>
<span class="cm"> * @param nbytes Amount of bytes of buf to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_buf_pr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write content of buffer into file</span>
<span class="cm"> *</span>
<span class="cm"> * @param buf Pointer to the buffer</span>
<span class="cm"> * @param nbytes Size of buf</span>
<span class="cm"> * @param path Destination where buffer will be dumped to</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_buf_to_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read content of file into buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @param buf Pointer to the buffer</span>
<span class="cm"> * @param nbytes Size of buf</span>
<span class="cm"> * @param path Source to read from</span>
<span class="cm"> *</span>
<span class="cm"> * @returns 0 on success, -1 on error and errno set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_buf_from_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Erase nvm at given addresses</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * The addresses given to this function are interpreted as block addresses, in</span>
<span class="cm"> * contrast to `nvm_addr_mark`, `nvm_addr_write`, and `nvm_addr_read` for which</span>
<span class="cm"> * the address is interpreted as a sector address.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addrs Array of memory address</span>
<span class="cm"> * @param naddrs Length of array of memory addresses</span>
<span class="cm"> * @param flags Access mode</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result.</span>
<span class="cm"> * @returns 0 on success. On error: returns -1, sets `errno` accordingly, and</span>
<span class="cm"> *          fills `ret` with lower-level result and status codes</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_addr_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addrs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">,</span>
		       <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write content of buf to nvm at address(es)</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * The addresses given to this function are interpreted as sector addresses, in</span>
<span class="cm"> * contrast to nvm_addr_mark and nvm_addr_erase for which the address is</span>
<span class="cm"> * interpreted as a block address.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addrs Array of memory address</span>
<span class="cm"> * @param naddrs Length of array of memory addresses</span>
<span class="cm"> * @param buf The buffer which content to write, must be aligned to device</span>
<span class="cm"> *            geometry of minimal write granularity and size equal to</span>
<span class="cm"> *            `naddrs * geo.nbytes`</span>
<span class="cm"> * @param meta Buffer containing metadata, must be of size equal to device</span>
<span class="cm"> *             `naddrs * geo.meta_nbytes`</span>
<span class="cm"> * @param flags Access mode</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result.</span>
<span class="cm"> * @returns 0 on success. On error: returns -1, sets `errno` accordingly, and</span>
<span class="cm"> *          fills `ret` with lower-level result and status codes</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_addr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addrs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">meta</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read content of nvm at addresses into buf</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * The addresses given to this function are interpreted as sector addresses, in</span>
<span class="cm"> * contrast to `nvm_addr_mark` and `nvm_addr_erase` for which the address is</span>
<span class="cm"> * interpreted as a block address.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addrs List of memory address</span>
<span class="cm"> * @param naddrs Length of array of memory addresses</span>
<span class="cm"> * @param buf Buffer to store result of read into, must be aligned to device</span>
<span class="cm"> *            granularity min read and size equal to `naddrs *</span>
<span class="cm"> *            geo.sector_nbytes`</span>
<span class="cm"> * @param meta Buffer to store content of metadata, must be of size equal to</span>
<span class="cm"> *             device `naddrs * geo.meta_nbytes`</span>
<span class="cm"> * @param flags Access mode</span>
<span class="cm"> * @param ret Pointer to structure in which to store lower-level status and</span>
<span class="cm"> *            result.</span>
<span class="cm"> * @returns 0 on success. On error: returns -1, sets `errno` accordingly, and</span>
<span class="cm"> *          fills `ret` with lower-level result and status codes</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_addr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addrs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">meta</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">nvm_ret</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Checks whether the given address exceeds bounds of the given geometry</span>
<span class="cm"> *</span>
<span class="cm"> * @param addr The addr to check</span>
<span class="cm"> * @param geo The geometric bounds to check the given address against</span>
<span class="cm"> * @returns A mask of exceeded boundaries</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_addr_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nvm_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address generic-format to device-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on generic-format to convert</span>
<span class="cm"> * @return Physical address on device-format</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">nvm_addr_gen2dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address on device-format to generic-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on device-format to convert</span>
<span class="cm"> * @return Physical address on generic-format</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="nf">nvm_addr_dev2gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address on device-format to lba-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on device-format to convert</span>
<span class="cm"> * @return Physical address on lba-format</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">nvm_addr_dev2lba</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address on device-format to lba-offset-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on device-format to convert</span>
<span class="cm"> * @return Physical address on lba-offset-format</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">nvm_addr_dev2off</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address on generic-format to byte offset</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on generic-format to convert</span>
<span class="cm"> * @return Logical address as byte offset</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">nvm_addr_gen2off</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given byte offset to physical address on generic-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param off Logical address as byte offset to convert</span>
<span class="cm"> * @return Physical address on generic-format</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="nf">nvm_addr_off2gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">off</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given physical address on generic-format to LBA offset</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addr The physical address on generic-format to convert</span>
<span class="cm"> * @return Logical address as LBA offset</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">nvm_addr_gen2lba</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Converts a given LBA offset to physical address on generic-format</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param off Logical address as LBA offset to convert</span>
<span class="cm"> * @return Physical address on generic-format</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="nf">nvm_addr_lba2gen</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">off</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation of the given address</span>
<span class="cm"> *</span>
<span class="cm"> * @param addr The address to print</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_addr_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation of the given list of addresses</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_addr_prn</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">naddrs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a virtual block, spanning a given set of physical blocks</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param addrs Set of block-addresses forming the virtual block</span>
<span class="cm"> * @param naddrs The number of addresses in the address-set</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, an opaque pointer to the initialized virtual block is</span>
<span class="cm"> * returned. On error, NULL and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="nf">nvm_vblk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nvm_addr</span> <span class="n">addrs</span><span class="p">[],</span>
				<span class="kt">int</span> <span class="n">naddrs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a virtual block (spanning planes, channels, and LUNs)</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with `nvm_dev_open`</span>
<span class="cm"> * @param ch_bgn Beginning of the channel span, as inclusive index</span>
<span class="cm"> * @param ch_end End of the channel span, as inclusive index</span>
<span class="cm"> * @param lun_bgn Beginning of the LUN span, as inclusive index</span>
<span class="cm"> * @param lun_end End of the LUN span, as inclusive index</span>
<span class="cm"> * @param blk Block index</span>
<span class="cm"> *</span>
<span class="cm"> * @returns On success, an opaque pointer to the initialized virtual block is</span>
<span class="cm"> * returned.  On error, NULL and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="nf">nvm_vblk_alloc_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch_bgn</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">ch_end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun_bgn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun_end</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">blk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroy a virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The virtual block to destroy</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_vblk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Erase a virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * Erasing a vblk will reset internal position pointers</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The virtual block to erase</span>
<span class="cm"> * @returns On success, the number of bytes erased is returned. On error, -1 is</span>
<span class="cm"> * returned and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write to a virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * buf must be aligned to device geometry, see struct nvm_geo and nvm_buf_alloc</span>
<span class="cm"> * count must be a multiple of min-size, see struct nvm_geo</span>
<span class="cm"> * do not mix use of nvm_vblk_pwrite with nvm_vblk_write on the same virtual</span>
<span class="cm"> * block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The virtual block to write to</span>
<span class="cm"> * @param buf Write content starting at buf</span>
<span class="cm"> * @param count The number of bytes to write</span>
<span class="cm"> * @returns On success, the number of bytes written is returned and vblk</span>
<span class="cm"> * internal position is updated. On error, -1 is returned and `errno` set to</span>
<span class="cm"> * indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Write to a virtual block at a given offset</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * buf must be aligned to device geometry, see struct nvm_geo and nvm_buf_alloc</span>
<span class="cm"> * count must be a multiple of min-size, see struct nvm_geo</span>
<span class="cm"> * offset must be a multiple of min-size, see struct nvm_geo</span>
<span class="cm"> * do not mix use of nvm_vblk_pwrite with nvm_vblk_write on the same virtual</span>
<span class="cm"> * block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The virtual block to write to</span>
<span class="cm"> * @param buf Write content starting at buf</span>
<span class="cm"> * @param count The number of bytes to write</span>
<span class="cm"> * @param offset Start writing offset bytes within virtual block</span>
<span class="cm"> * @returns On success, the number of bytes written is returned. On error, -1 is</span>
<span class="cm"> * returned and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_pwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Pad the virtual block with synthetic data</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * Assumes that you have used nvm_vblk_write and now want to fill the remaining</span>
<span class="cm"> * virtual block in order to meet block write-before-read constraints</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The virtual block to pad</span>
<span class="cm"> * @returns On success, the number of bytes padded is returned and internal</span>
<span class="cm"> * position is updated. On error, -1 is returned and `errno` set to indicate the</span>
<span class="cm"> * error.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read from a virtual block</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Read from a virtual block at given offset</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nvm_vblk_pread</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">offset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the device associated with the given virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_dev</span> <span class="o">*</span><span class="nf">nvm_vblk_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the set of addresses defining the virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nvm_addr</span> <span class="o">*</span><span class="nf">nvm_vblk_get_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the number of addresses in the address set of the virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nvm_vblk_get_naddrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the size, in bytes, of a given virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nvm_vblk_get_nbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the current cursor position for read to the virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nvm_vblk_get_pos_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the current cursor position for writes to the virtual block</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to retrieve information from</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nvm_vblk_get_pos_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Print the virtual block in a humanly readable form</span>
<span class="cm"> *</span>
<span class="cm"> * @param vblk The entity to print information about</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nvm_vblk_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nvm_vblk</span> <span class="o">*</span><span class="n">vblk</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LIBLIGHTNVM.H */</span><span class="cp"></span>
</pre></div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cli/index.html" class="btn btn-neutral float-right" title="Command-Line Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nvm_bounds.html" class="btn btn-neutral" title="nvm_bounds" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, LightNVM.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>